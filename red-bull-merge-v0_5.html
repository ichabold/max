<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Red Bull Merge — Max vs. Caravans (v0.5)</title>
<style>
  :root{ --rb-blue:#0b1a33; --rb-red:#e10600; --rb-yellow:#ffd100; --rb-navy:#001f3f; }
  *{box-sizing:border-box; touch-action:manipulation}
  html,body{height:100%; margin:0; background:radial-gradient(1200px 600px at 50% 20%, #062041 0, #031327 55%, #01060e 100%); color:#eef3ff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif; overflow:hidden}
  .app{height:100vh; display:grid; grid-template-columns:1fr; gap:12px; padding:12px; max-width:1440px; margin:0 auto}
  header{grid-column:1/-1; display:flex; align-items:center; justify-content:space-between; gap:12px; padding:10px 14px; background:linear-gradient(180deg,rgba(255,255,255,.08),rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.12); border-radius:14px; backdrop-filter: blur(6px)}
  .badge{display:inline-block; padding:4px 10px; border-radius:999px; background:linear-gradient(90deg,var(--rb-yellow),var(--rb-red)); color:#091221; font-weight:900; margin-left:8px; letter-spacing:.2px}
  .main{display:grid; grid-template-columns:1fr; gap:12px; min-height:0}
  @media(min-width:980px){
    .app{grid-template-columns:2.15fr 1fr}
    header{grid-column:1/-1}
    .main{grid-column:1/2; min-height:0}
    .side{grid-column:2/3; min-height:0; overflow:auto}
  }
  .stageWrap{display:flex; flex-direction:column; gap:10px; min-height:0}
  .stage{
    position:relative; width:100%; background:#021726;
    border:1px solid rgba(255,255,255,.14); border-radius:16px; overflow:hidden; box-shadow:0 10px 50px rgba(0,0,0,.55) inset, 0 10px 40px rgba(0,0,0,.35);
    min-height:0;
  }
  canvas{width:100%; height:100%; display:block}
  .pad{display:flex; gap:12px}
  .pad button{flex:1; min-height:56px; font-size:18px; border-radius:12px; font-weight:800; letter-spacing:.5px; border:1px solid rgba(255,255,255,.18); background:#0c2b4e; color:#fff; cursor:pointer; box-shadow:0 8px 22px rgba(0,0,0,.25)}
  .pad button:active{ transform:scale(.98) }
  .panel{background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.14); border-radius:12px; padding:14px; display:flex; flex-direction:column; gap:12px; box-shadow:0 10px 30px rgba(0,0,0,.2) inset}
  .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
  .tag{background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.16); padding:6px 10px; border-radius:9px; font-size:14px; box-shadow:0 4px 12px rgba(0,0,0,.2) inset}
  .leader{background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.14); border-radius:10px; padding:10px}
  .leader h3{margin:0 0 8px 0; font-size:16px}
  .leader ol{margin:0; padding-left:18px}
  .leader li{margin:4px 0}
  .muted{opacity:.85}
  .btn{appearance:none; border:0; padding:9px 14px; border-radius:10px; font-weight:800; cursor:pointer}
  .btn.primary{background:linear-gradient(90deg,var(--rb-yellow),var(--rb-red)); color:#091221; box-shadow:0 8px 22px rgba(0,0,0,.25)}
  .btn.ghost{background:#143a67; color:#fff; border:1px solid rgba(255,255,255,.2)}
  .overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.35)); color:#fff; z-index:10; backdrop-filter:blur(3px)}
  .card{background:linear-gradient(180deg,rgba(8,20,39,.95),rgba(5,15,28,.95)); border:1px solid rgba(255,255,255,.12); border-radius:14px; padding:18px; width:min(560px,92%); box-shadow:0 20px 40px rgba(0,0,0,.5)}
  .card h2{margin:0 0 10px}
  .card p{margin:6px 0}
  .field{display:flex; gap:8px; margin-top:8px}
  .field input{flex:1; padding:12px 14px; border-radius:10px; border:1px solid rgba(255,255,255,.25); background:#0f2b52; color:#fff; outline:none; font-weight:600; letter-spacing:.3px}
  .card .row{justify-content:flex-end}
  footer{grid-column:1/-1; text-align:center; opacity:.8; font-size:12px}
</style>
</head>
<body>
  <div class="app">
    <header>
      <div><strong>Red Bull Merge</strong><span class="badge">Max vs. Caravans</span></div>
      <div class="row"><button id="btnReset" class="btn ghost">Réinitialiser</button></div>
    </header>
    <section class="main">
      <div class="stageWrap">
        <div class="stage" id="stage">
          <canvas id="game"></canvas>
          <div class="overlay" id="overlay">
            <div class="card">
              <h2>Entre ton nom, champion.</h2>
              <p class="muted">Objectif: <strong>te rabattre pile devant la voiture</strong> (pas la caravane) pour +100. Dépasser sans toucher: +30. Toucher la caravane: -1 vie. Tu en as 3, ne les gaspille pas.</p>
              <p class="muted">Route droite, vue 3/4 arrière. Délai de 3 s au début, +5% de vitesse par niveau. Facile, sur le papier.</p>
              <form id="gateForm">
                <div class="field"><input id="playerName" type="text" maxlength="16" placeholder="Ton pseudo éblouissant" autocomplete="name"></div>
                <div class="row" style="margin-top:10px"><button id="btnStart" class="btn primary" disabled>Démarrer (et impressionner personne)</button></div>
              </form>
            </div>
          </div>
        </div>
        <div class="pad"><button id="btnLeft">◀︎ Gauche</button><button id="btnRight">Droite ▶︎</button></div>
      </div>
    </section>
    <aside class="side">
      <div class="panel">
        <div class="row">
          <div class="tag">Vitesse: <span id="speed">0</span></div>
          <div class="tag">Score: <span id="score">0</span></div>
          <div class="tag">Vies: <span id="lives">3</span></div>
          <div class="tag">Niveau: <span id="level">1</span></div>
        </div>
        <div class="leader">
          <h3>Meilleurs scores (sur ton ordi seulement, relax)</h3>
          <ol id="board"></ol>
          <div id="storageWarn" class="muted" style="display:none">Stockage local indisponible. Ton navigateur vit dans la peur.</div>
        </div>
        <div class="row">
          <button id="btnAudio" class="btn ghost">Tester le son</button>
          <span id="audioState" class="muted">Audio: inconnu</span>
        </div>
        <div class="muted">Contrôles: ← → ou boutons. Pas de scroll. 9/16 sur mobile. Bonne chance, prodige autoproclamé.</div>
      </div>
    </aside>
    <footer>Vibes Red Bull. Caravanes XXL. Ego fragile non remboursé.</footer>
  </div>
<script>
(function(){
  // DOM
  const stage = document.getElementById('stage');
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const form = document.getElementById('gateForm');
  const nameInput = document.getElementById('playerName');
  const btnStart = document.getElementById('btnStart');
  const btnLeft = document.getElementById('btnLeft');
  const btnRight = document.getElementById('btnRight');
  const btnReset = document.getElementById('btnReset');
  const btnAudio = document.getElementById('btnAudio');
  const audioStateEl = document.getElementById('audioState');
  const speedEl = document.getElementById('speed');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const levelEl = document.getElementById('level');
  const boardEl = document.getElementById('board');
  const storageWarn = document.getElementById('storageWarn');

  // Fit stage height to viewport (no scroll on laptop; 9/16 on mobile)
  function fitStage(){
    const headerH = document.querySelector('header').getBoundingClientRect().height;
    const footerH = document.querySelector('footer').getBoundingClientRect().height;
    const padH = 72;
    const margins = 36;
    const available = Math.max(320, window.innerHeight - headerH - footerH - padH - margins);
    stage.style.height = available + 'px';
    if(window.innerWidth < 980){
      stage.style.aspectRatio = '9/16';
    }else{
      stage.style.aspectRatio = '';
    }
    resizeCanvas();
  }
  window.addEventListener('resize', fitStage);
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * devicePixelRatio);
    canvas.height = Math.floor(rect.height * devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }

  // Game state
  const LANES = 3;
  let laneIndex = 1;
  let raf = 0, running = false, lastTime = 0;
  let level = 1;
  let score = 0;
  let lives = 3;
  let rigs = [];
  let spawnTimer = 0;
  let spawnGap = 3.0; // seconds to collision zone initially
  const LEVEL_STEP = 5;
  let processedThisLevel = 0;
  let lastLaneChangeAt = 0;

  // Audio (speech or beep fallback)
  let audioCtx = null;
  function unlockAudio(){
    try{ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); if(audioCtx.state==='suspended') audioCtx.resume(); audioStateEl.textContent='Audio: OK'; }
    catch(e){ audioStateEl.textContent='Audio: limité'; }
  }
  function beep(freq=600, dur=0.2){
    if(!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type='square'; o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0.0001,t0); g.gain.exponentialRampToValueAtTime(0.3,t0+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001,t0+dur);
    o.connect(g).connect(audioCtx.destination); o.start(t0); o.stop(t0+dur+0.02);
  }
  function say(text){
    if('speechSynthesis' in window){
      const u = new SpeechSynthesisUtterance(text); u.lang='en-US'; u.rate=1.05; window.speechSynthesis.cancel(); window.speechSynthesis.speak(u);
    }else{ beep(); }
  }
  btnAudio.addEventListener('click', ()=>{ unlockAudio(); say('simply lovely'); });

  // Storage
  const LS_NAME = 'rb-merge-v05-name';
  const LS_BOARD = 'rb-merge-v05-board';
  function safeGet(key, fallback){ try{ const raw = localStorage.getItem(key); return raw?JSON.parse(raw):fallback; }catch(e){ storageWarn.style.display='block'; return fallback; } }
  function safeSet(key, val){ try{ localStorage.setItem(key, JSON.stringify(val)); storageWarn.style.display='none'; return true; }catch(e){ storageWarn.style.display='block'; return false; } }
  function boardGet(){ return safeGet(LS_BOARD, []); }
  function boardSave(b){ return safeSet(LS_BOARD, b); }
  function boardSubmit(name, s){
    if(!name || s<=0) return;
    let b = boardGet();
    const i = b.findIndex(e=> e.name.toLowerCase()===name.toLowerCase());
    if(i>=0){ if(s>b[i].score) b[i].score=s; } else { b.push({name, score:s}); }
    b.sort((a,b)=> b.score-a.score); b=b.slice(0,10); boardSave(b); boardRender();
  }
  function boardRender(){
    const b = boardGet();
    boardEl.innerHTML='';
    if(!b.length){ const li=document.createElement('li'); li.textContent='Personne… encore. Courage.'; boardEl.appendChild(li); return; }
    b.forEach(row=>{ const li=document.createElement('li'); li.textContent=`${row.name}: ${row.score}`; boardEl.appendChild(li); });
  }

  // Perspective lane center with straight road (no lateral offset)
  function laneCenterX(lane, yPx){
    const w = canvas.width / devicePixelRatio;
    const h = canvas.height / devicePixelRatio;
    const horizon = h*0.18;
    const roadWidthBottom = w*0.78;
    const roadWidthTop = w*0.20;
    const depth = Math.max(0, (yPx - horizon) / (h - horizon));
    const roadWidth = roadWidthTop + (roadWidthBottom - roadWidthTop) * Math.pow(depth, 0.9);
    const laneWidth = roadWidth/3;
    const centerBase = w*0.5;
    const leftEdge = centerBase - roadWidth/2;
    return leftEdge + laneWidth*(lane+0.5);
  }

  // Pretty straight road with highlights, vignette, motion lines
  function drawRoad(){
    const w = canvas.width / devicePixelRatio;
    const h = canvas.height / devicePixelRatio;
    const horizon = h*0.18;

    // backdrop sky gradient
    const sky = ctx.createLinearGradient(0,0,0,horizon);
    sky.addColorStop(0,'#0b2650'); sky.addColorStop(1,'#071732');
    ctx.fillStyle = sky; ctx.fillRect(0,0,w,horizon);

    // parallax banners
    ctx.fillStyle = 'rgba(255,255,255,.05)';
    for(let i=0;i<w;i+=180){
      ctx.fillRect(i+((performance.now()/30)%180), horizon-22, 60, 8);
    }

    // grass
    const grass = ctx.createLinearGradient(0,horizon,0,h);
    grass.addColorStop(0,'#0a4f35'); grass.addColorStop(1,'#053a29');
    ctx.fillStyle = grass; ctx.fillRect(0,horizon,w,h-horizon);

    // asphalt base with subtle noise bands
    for(let y=horizon; y<h; y+=8){
      const x0 = laneCenterX(0, y) - (laneCenterX(1,y)-laneCenterX(0,y))/2;
      const x2 = laneCenterX(2, y) + (laneCenterX(2,y)-laneCenterX(1,y))/2;
      ctx.strokeStyle = y%16===0 ? '#2c3347' : '#252b3d';
      ctx.lineWidth = 8; ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x2,y); ctx.stroke();
    }

    // specular highlight down the middle
    ctx.globalAlpha = 0.08;
    for(let y=horizon; y<h; y+=24){
      const xm = (laneCenterX(1,y)+laneCenterX(0,y))/2;
      ctx.fillStyle = '#cbd3ff';
      ctx.fillRect(xm-2, y, 4, 14);
    }
    ctx.globalAlpha = 1;

    // edges
    ctx.setLineDash([]); ctx.lineWidth = 4; ctx.strokeStyle = '#ff3b3b';
    for(const edge of [0,2]){
      ctx.beginPath();
      for(let y=horizon; y<h; y+=4){
        const x = laneCenterX(edge, y) + (edge===0?-1:1)*(laneCenterX(1,y)-laneCenterX(0,y))/2;
        if(y===horizon) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    // lane markers
    ctx.setLineDash([16,16]); ctx.lineWidth = 2.5; ctx.strokeStyle = '#e8e8e8';
    for(let lane=1; lane<3; lane++){
      ctx.beginPath();
      for(let y=horizon; y<h; y+=4){
        const x = (laneCenterX(lane,y) + laneCenterX(lane-1,y))/2;
        if(y===horizon) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }
    ctx.setLineDash([]);

    // vignette
    const vg = ctx.createRadialGradient(w/2,h*0.6,Math.min(w,h)*0.2, w/2,h*0.6, Math.max(w,h)*0.7);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.4)');
    ctx.fillStyle = vg; ctx.fillRect(0,0,w,h);
  }

  // F1 detailed with reflections
  function drawF1(x, y, scale){
    ctx.save();
    ctx.translate(x,y); ctx.scale(scale,scale);
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.beginPath(); ctx.ellipse(0,20,28,11,0,0,Math.PI*2); ctx.fill();
    // floor
    const floor = ctx.createLinearGradient(-26,10,26,18);
    floor.addColorStop(0,'#071427'); floor.addColorStop(1,'#0e2447');
    ctx.fillStyle = floor; ctx.fillRect(-26,10,52,8);
    // body
    const body = ctx.createLinearGradient(0,-30,0,28);
    body.addColorStop(0,'#0b1a33'); body.addColorStop(1,'#001428');
    ctx.fillStyle = body; ctx.strokeStyle = '#dbe2ff'; ctx.lineWidth = 1.4;
    ctx.beginPath();
    ctx.moveTo(0,-30); ctx.quadraticCurveTo(20,-22,22,0); ctx.quadraticCurveTo(20,20,0,28);
    ctx.quadraticCurveTo(-20,20,-22,0); ctx.quadraticCurveTo(-20,-22,0,-30); ctx.closePath(); ctx.fill(); ctx.stroke();
    // red/yellow livery
    ctx.fillStyle='#e10600'; ctx.fillRect(-6,-26,12,12);
    ctx.fillStyle='#ffd100'; ctx.fillRect(-24,2,16,6); ctx.fillRect(8,2,16,6);
    // wings
    ctx.fillStyle='#0e2143'; ctx.fillRect(-28,24,56,5); ctx.fillRect(-28,-6,56,4);
    // halo
    ctx.strokeStyle='#ebeef7'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(-8,-12); ctx.arc(0,-12,8,Math.PI,0); ctx.stroke();
    // wheels
    ctx.fillStyle='#0c0c0c'; ctx.fillRect(-26,8,8,8); ctx.fillRect(18,8,8,8);
    // glossy streak
    ctx.globalAlpha=0.25; ctx.fillStyle='#ffffff'; ctx.fillRect(-20,-8,10,3); ctx.globalAlpha=1;
    ctx.restore();
  }

  // Detailed rig (car + long caravan train)
  function drawRig(laneX, y, scale, highlight=false){
    ctx.save();
    ctx.translate(laneX, y); ctx.scale(scale, scale);
    // towing car with glossy paint
    const grd = ctx.createLinearGradient(-18,-38,18,-10);
    grd.addColorStop(0, highlight ? '#6a86ff' : '#1f2c46');
    grd.addColorStop(0.5, highlight ? '#8fb2ff' : '#324462');
    grd.addColorStop(1, highlight ? '#a7c1ff' : '#4a5a7a');
    ctx.fillStyle = grd;
    ctx.strokeStyle='#e5e9f0'; ctx.lineWidth=1;
    roundRect(-18,-38,36,26,6,true);
    // chrome bumper
    const chrome = ctx.createLinearGradient(-18,-12,18,-6);
    chrome.addColorStop(0,'#cfd6e3'); chrome.addColorStop(0.5,'#ffffff'); chrome.addColorStop(1,'#cfd6e3');
    ctx.fillStyle = chrome; roundRect(-18,-12,36,5,2,true);
    // windows
    const glass = ctx.createLinearGradient(-12,-32,-2,-24);
    glass.addColorStop(0,'#9ac2ff'); glass.addColorStop(1,'#e8f1ff');
    ctx.fillStyle=glass; roundRect(-12,-32,12,9,2,true); roundRect(2,-32,12,9,2,true);
    // lights
    ctx.fillStyle='#ffd34d'; roundRect(-16,-8,7,3,1,true); roundRect(9,-8,7,3,1,true);

    // long tow bar
    const barLen = 18 * 4;
    ctx.strokeStyle='#555'; ctx.lineWidth=2.2; ctx.beginPath(); ctx.moveTo(0,-12); ctx.lineTo(0,-12+barLen); ctx.stroke();

    // elongated caravan train (4 segments)
    const bodyH = 28, bodyW = 40, segs = 4;
    for(let i=0;i<segs;i++){
      const off = -12 + barLen + i*(bodyH+5);
      const cgrd = ctx.createLinearGradient(-bodyW/2,off,bodyW/2,off+bodyH);
      cgrd.addColorStop(0,'#f8f8fb'); cgrd.addColorStop(1,'#d8dbe6');
      ctx.fillStyle = cgrd; ctx.strokeStyle='#c7cfdb';
      roundRect(-bodyW/2, off, bodyW, bodyH, 8, true);
      // window band with reflection
      const wgr = ctx.createLinearGradient(-bodyW/2+6,off+6, bodyW/2-6,off+16);
      wgr.addColorStop(0,'#a6b7ff'); wgr.addColorStop(1,'#eef3ff');
      ctx.fillStyle = wgr; roundRect(-bodyW/2+6, off+6, bodyW-12, 10, 4, true);
      // wheels
      ctx.fillStyle='#131416'; ctx.beginPath(); ctx.arc(-bodyW/2+8, off+bodyH-3, 3, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(bodyW/2-8, off+bodyH-3, 3, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }
  function roundRect(x,y,w,h,r,stroke){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    ctx.fill();
    if(stroke) ctx.stroke();
  }

  // Hitboxes
  function rigBoxes(lane, y, h){
    const carY = y + 20;
    const carX = laneCenterX(lane, carY);
    const scaleCar = Math.min(1.5, Math.max(0.3, (carY / h)*1.2));
    const carBox = {x:carX-18*scaleCar, y:carY-14*scaleCar, w:36*scaleCar, h:24*scaleCar};
    const trainLenPx = 18*4 + (28*4) + 12;
    const caraY = y + 20 + trainLenPx*scaleCar*0.7;
    const caraX = laneCenterX(lane, caraY);
    const scaleCara = Math.min(1.8, Math.max(0.35, (caraY / h)*1.3));
    const caraBox = {x:caraX-22*scaleCara, y:caraY-10*scaleCara, w:44*scaleCara, h:30*scaleCara};
    return {carBox, caraBox};
  }
  function playerBox(){
    const h = canvas.height / devicePixelRatio;
    const yPx = h*0.8;
    const x = laneCenterX(laneIndex, yPx);
    return {box:{x:x-18, y:yPx-30, w:36, h:60}, x, y:yPx};
  }
  function overlap(a,b){ return !(a.x+a.w<b.x || b.x+b.w<a.x || a.y+a.h<b.y || b.y+b.h<a.y); }

  // Spawn respecting 3s lead
  function spawnRig(){
    const lane = Math.floor(Math.random()*LANES);
    const h = canvas.height / devicePixelRatio;
    const yStart = -60;
    const p = playerBox();
    const distance = (p.y - yStart) - 40;
    const speedNeeded = distance / spawnGap; // px/sec to reach player in spawnGap
    const r = { lane, y:yStart, speed: Math.max(90, speedNeeded), merged:false, passed:false };
    rigs.push(r);
  }

  function update(dt){
    // spawn cadence
    spawnTimer -= dt;
    if(spawnTimer <= 0){
      spawnRig();
      spawnTimer = 1.6 + Math.random()*0.9;
    }
    // speed factor
    const factor = Math.pow(1.05, level-1);
    for(const r of rigs){ r.y += r.speed * factor * dt; }

    const h = canvas.height / devicePixelRatio;
    const p = playerBox();

    for(let i=rigs.length-1;i>=0;i--){
      const r = rigs[i];
      const {carBox, caraBox} = rigBoxes(r.lane, r.y, h);

      // caravan collision
      if(overlap(p.box, caraBox)){
        lives -= 1; livesEl.textContent = lives;
        say("what an idiot");
        rigs.splice(i,1);
        processedThisLevel++;
        if(lives<=0){ endGame(); return; }
        continue;
      }

      // merge success: player just ahead of car after lane change
      const now = performance.now();
      const justChanged = (now - lastLaneChangeAt) < 600;
      if(!r.merged && laneIndex===r.lane && p.box.y < carBox.y - 8 && p.box.y > carBox.y - 54 && justChanged){
        score += 100; scoreEl.textContent = score; r.merged = true; say("simply lovely");
      }

      // passed cleanly off screen
      if(r.y > h + 200){
        if(!r.merged){
          score += 30; scoreEl.textContent = score; say("I can't turn");
        }
        rigs.splice(i,1);
        processedThisLevel++;
      }
    }

    // level up
    if(processedThisLevel >= LEVEL_STEP){
      processedThisLevel = 0;
      level += 1; levelEl.textContent = level;
      spawnGap = Math.max(1.6, spawnGap*0.95);
    }
  }

  function draw(){
    drawRoad();
    const h = canvas.height / devicePixelRatio;
    // rigs
    for(const r of rigs){
      const carY = r.y + 20;
      const carX = laneCenterX(r.lane, carY);
      const scale = Math.min(1.6, Math.max(0.35, (carY/h)*1.2));
      drawRig(carX, carY, scale, r.merged);
    }
    // player
    const p = playerBox();
    drawF1(p.x, p.y, 1);
  }

  function loop(ts){
    if(!running) return;
    const dt = Math.min(0.033, (ts - lastTime)/1000 || 0.016);
    lastTime = ts;
    update(dt);
    speedEl.textContent = Math.round( (spawnGap>0 ? (1/spawnGap)*100 : 100) * Math.pow(1.05, level-1) );
    ctx.clearRect(0,0,canvas.width,canvas.height);
    draw();
    raf = requestAnimationFrame(loop);
  }

  function startGame(){
    overlay.style.display = 'none';
    running = true; lastTime = performance.now();
    rigs.length = 0; score = 0; lives = 3; level = 1; processedThisLevel = 0;
    scoreEl.textContent = score; livesEl.textContent = lives; levelEl.textContent = level;
    spawnGap = 3.0; spawnTimer = 0.4;
    loop(lastTime);
  }

  function endGame(){
    running = false; cancelAnimationFrame(raf);
    const name = (nameInput.value||'').trim() || 'Anonyme';
    boardSubmit(name, score);
    overlay.style.display = 'flex';
    overlay.querySelector('.card').innerHTML = `
      <h2>Fin de course</h2>
      <p>Score: <strong>${score}</strong></p>
      <p class="muted">Tu peux faire mieux. Ou pas. Mais essaie quand même.</p>
      <div class="row" style="margin-top:10px; justify-content:flex-end">
        <button id="again" class="btn primary">Rejouer (et prouver un point à personne)</button>
      </div>`;
    document.getElementById('again').addEventListener('click', ()=>{ unlockAudio(); startGame(); });
  }

  function resetGame(){
    running = false; cancelAnimationFrame(raf);
    overlay.style.display = 'flex';
    overlay.querySelector('.card').innerHTML = `
      <h2>Entre ton nom, champion.</h2>
      <p class="muted"><strong>Objectif:</strong> te rabattre devant la voiture pour +100, dépasser sans toucher pour +30, caravane = -1 vie.</p>
      <form id="gateForm2">
        <div class="field"><input id="playerName2" type="text" maxlength="16" placeholder="Ton pseudo éblouissant" autocomplete="name"></div>
        <div class="row" style="margin-top:10px"><button id="btnStart2" class="btn primary" disabled>Démarrer</button></div>
      </form>`;
    const form2 = document.getElementById('gateForm2');
    const name2 = document.getElementById('playerName2');
    const start2 = document.getElementById('btnStart2');
    const validate2 = ()=>{ start2.disabled = name2.value.trim().length<2; };
    name2.addEventListener('input', validate2);
    const saved = safeGet(LS_NAME,'');
    if(typeof saved==='string'){ name2.value=saved; validate2(); }
    form2.addEventListener('submit', (e)=>{ e.preventDefault(); if(start2.disabled) return; nameInput.value = name2.value.trim(); safeSet(LS_NAME,nameInput.value); startGame(); });
  }

  // Controls
  function moveLeft(){ laneIndex = Math.max(0, laneIndex-1); lastLaneChangeAt = performance.now(); }
  function moveRight(){ laneIndex = Math.min(LANES-1, laneIndex+1); lastLaneChangeAt = performance.now(); }
  window.addEventListener('keydown', e=>{
    if(e.key==='ArrowLeft'){ unlockAudio(); moveLeft(); }
    else if(e.key==='ArrowRight'){ unlockAudio(); moveRight(); }
    else if(e.key==='r' || e.key==='R'){ resetGame(); }
  });
  btnLeft.addEventListener('click', ()=>{ unlockAudio(); moveLeft(); });
  btnRight.addEventListener('click', ()=>{ unlockAudio(); moveRight(); });
  btnReset.addEventListener('click', resetGame);

  // Name gate
  nameInput.addEventListener('input', ()=>{ btnStart.disabled = nameInput.value.trim().length<2; });
  form.addEventListener('submit', e=>{
    e.preventDefault();
    if(btnStart.disabled) return;
    unlockAudio();
    safeSet(LS_NAME, nameInput.value.trim());
    startGame();
  });
  const saved = safeGet(LS_NAME, '');
  if(typeof saved==='string'){ nameInput.value = saved; btnStart.disabled = saved.trim().length<2; }

  // Init
  fitStage();
  boardRender();
  ['pointerdown','mousedown','touchstart','keydown'].forEach(evt=>{
    window.addEventListener(evt, ()=>{ unlockAudio(); }, { once:true, passive:true });
  });

})();</script>
</body>
</html>
